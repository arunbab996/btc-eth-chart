<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Magic Internet Money</title>

  <!-- Favicon: Bitcoin mark (inline SVG) -->
  <link rel="icon" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='50' fill='%23f7931a'/><text x='50' y='62' font-size='56' text-anchor='middle' fill='white' font-family='Arial, Helvetica, sans-serif'>฿</text></svg>">

  <!-- Chart.js v4 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <style>
    :root{
      --bg:#f5f7fb;
      --card:#fff;
      --muted:#6b7280;
      --btc:#f7931a;
      --eth:#2f7ed8;
    }
    html,body{height:100%;margin:0;overflow:hidden}
    body{
      background:var(--bg);
      font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial;
      color:#071122;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:12px;
      box-sizing:border-box;
    }

    /* container */
    .card{
      width:96%;
      max-width:1260px;
      background:var(--card);
      border-radius:12px;
      padding:14px;
      box-shadow:0 10px 30px rgba(12,20,44,0.06);
      box-sizing:border-box;
      max-height: calc(100vh - 24px);
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:hidden;
    }

    header{display:flex;align-items:flex-start;justify-content:space-between;gap:12px}
    .left{display:flex;flex-direction:column;gap:6px}
    h1{margin:0;font-size:16px}
    .meta{font-size:13px;color:var(--muted)}
    .controls{display:flex;gap:8px;align-items:center}
    input,button,select{padding:6px 8px;border-radius:8px;border:1px solid #e6e9ef;background:white}
    #chart{width:100%;height:100%;display:block;margin-top:12px}

    .main { display:flex; gap:12px; align-items:stretch; flex:1 1 auto; min-height:0; }
    .chart-wrap { flex:1 1 auto; min-height:0; display:flex; flex-direction:column; gap:8px; }
    .right { width:280px; flex:0 0 280px; display:flex; flex-direction:column; gap:12px; align-items:stretch; box-sizing:border-box; }

    .price-card {
      width:100%;
      background:#fff;
      border-radius:8px;
      padding:10px;
      box-shadow:0 4px 12px rgba(12,20,44,0.04);
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:8px;
      cursor:pointer;
      user-select:none;
      transition: box-shadow 180ms, transform 180ms, border-color 180ms;
      border:2px solid rgba(0,0,0,0.00);
    }
    .price-card:hover{ transform: translateY(-3px); }
    .price-card.active { border-color: rgba(0,0,0,0.06); box-shadow:0 12px 30px rgba(12,20,44,0.10); transform: translateY(-6px); }

    .price-row { display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .price-label { font-size:12px;color:var(--muted) }
    .price-value { font-weight:700;font-size:18px }
    .price-change { font-size:12px;color:var(--muted) }

    .sparkline { width:100%; height:36px; background:transparent; border-radius:4px; }
    .small{font-size:12px;color:var(--muted)}
    footer{font-size:12px;color:var(--muted);text-align:center}

    .chart-canvas { flex:1 1 auto; min-height:0; position:relative; }
    canvas { width:100% !important; height:100% !important; display:block; }

    .btn-ghost{background:transparent;border:1px solid #e6e9ef;padding:6px 8px;border-radius:8px}

    @media (max-width:980px){ .right { width:200px; flex:0 0 200px } }
    @media (max-width:700px){
      .card{padding:12px}
      header{flex-direction:column;align-items:flex-start}
      .main{flex-direction:column}
      .right{width:100%;flex:0 0 auto;order:2}
      .chart-wrap{order:1}
    }
  </style>
</head>
<body data-ref-image="/mnt/data/Screenshot 2025-11-22 at 3.24.00 PM.png">
  <div class="card" role="main">
    <header>
      <div class="left">
        <h1>Live Tick Chart — BTC / ETH</h1>
        <div class="meta">Click a price on the right to switch the main chart to that symbol. Chart collects ticks from page load (or when you clear/start for a symbol).</div>
      </div>

      <div class="controls">
        <label class="meta">Max ticks</label>
        <input id="maxPoints" type="number" min="50" value="400" style="width:90px" />
        <label class="meta">Fallback</label>
        <select id="fallbackInterval" title="REST fallback interval (seconds)">
          <option value="2">2s</option>
          <option value="5" selected>5s</option>
          <option value="10">10s</option>
        </select>
        <button id="apply">Apply</button>
      </div>
    </header>

    <div class="main">
      <div class="chart-wrap">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
          <div id="priceStatus">BTC USDT: —</div>
          <div id="startedAt" class="meta">Started at: —</div>
        </div>

        <div class="chart-canvas">
          <canvas id="chart" aria-label="Live tick chart"></canvas>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center">
          <div id="last" class="meta">Last update: —</div>
          <div class="meta">Source: Binance WebSocket</div>
        </div>
      </div>

      <div class="right" aria-label="Live prices">
        <!-- BTC panel -->
        <div id="btcPanel" class="price-card active" role="button" aria-pressed="true">
          <div class="price-row">
            <div>
              <div class="price-label">BTC (Live)</div>
              <div class="price-value" id="btcLive">—</div>
            </div>
            <div style="text-align:right">
              <div class="price-change" id="btcChange"> </div>
              <div style="height:6px"></div>
              <button id="btcClear" class="btn-ghost" title="Clear BTC data">Clear</button>
            </div>
          </div>
          <canvas id="btcSpark" class="sparkline" aria-hidden="true"></canvas>
        </div>

        <!-- ETH panel -->
        <div id="ethPanel" class="price-card" role="button" aria-pressed="false">
          <div class="price-row">
            <div>
              <div class="price-label">ETH (Live)</div>
              <div class="price-value" id="ethLive">—</div>
            </div>
            <div style="text-align:right">
              <div class="price-change" id="ethChange"> </div>
              <div style="height:6px"></div>
              <button id="ethClear" class="btn-ghost" title="Clear ETH data">Clear</button>
            </div>
          </div>
          <canvas id="ethSpark" class="sparkline" aria-hidden="true"></canvas>
        </div>

        <div style="display:flex;gap:8px;align-items:center">
          <label class="small"><input id="startOnClick" type="checkbox" /> Start on click</label>
        </div>

        <!-- hidden reference image path for tooling -->
        <img src="/mnt/data/Screenshot 2025-11-22 at 3.24.00 PM.png" alt="ref" style="display:none" />
      </div>
    </div>

    <footer>Tip: if using Cloudflare, set the DNS record to DNS-only (grey cloud) to allow WebSocket upgrades.</footer>
  </div>

<script>
/*
  Final behavior:
  - BTC & ETH collected separately from Binance combined stream
  - Right panels show live prices and are clickable; clicking swaps main chart
  - Smoother chart visuals: Chart.js animations enabled; y-axis smoothing (EMA) tuned
  - 'Start on click' clears and sets that symbol's capture start time when checked
  - Clear buttons wipe that symbol's stored ticks
*/

// ---------- configuration ----------
let MAX_POINTS = Math.max(50, Number(document.getElementById('maxPoints').value) || 400);
let REST_INTERVAL_SEC = Number(document.getElementById('fallbackInterval').value) || 5;

const pageLoadTime = Date.now();
const symbolStart = { BTC: pageLoadTime, ETH: pageLoadTime }; // per-symbol capture start

// per-symbol buffers
const btcLabels = []; const btcPrices = []; const btcVolumes = [];
const ethLabels = []; const ethPrices = []; const ethVolumes = [];

let activeSymbol = 'BTC'; // visible on main chart
let lastBTC = null, lastETH = null;
let prevBTC = null, prevETH = null;

// chart context
const ctx = document.getElementById('chart').getContext('2d');

// ---------- Chart.js main chart ----------
const chart = new Chart(ctx, {
  data: {
    labels: btcLabels,
    datasets: [
      {
        type: 'line',
        label: 'Price',
        data: btcPrices,
        borderColor: '#f7931a',
        backgroundColor: '#f7931a',
        borderWidth: 2,
        pointRadius: 3,
        stepped: true,
        yAxisID: 'price',
        tension: 0.02,
      },
      {
        type: 'bar',
        label: 'Qty',
        data: btcVolumes,
        backgroundColor: 'rgba(247,147,26,0.22)',
        yAxisID: 'volume',
      }
    ]
  },
  options: {
    animation: { duration: 160, easing: 'linear' }, // smooth small animations
    maintainAspectRatio: false,
    responsive: true,
    interaction: { mode: 'index', intersect: false },
    plugins: { legend: { display: false } },
    scales: {
      x: { ticks: { maxRotation: 45, autoSkip: true, maxTicksLimit: 30 } },
      price: { type: 'linear', position: 'left', title: { display: true, text: 'Price (USDT)' }, grid: { drawOnChartArea: true } },
      volume: { type: 'linear', position: 'right', title: { display: true, text: 'Quantity' }, grid: { drawOnChartArea: false } }
    }
  }
});

// ---------- per-symbol axis smoothing ----------
let emaPriceMin = null, emaPriceMax = null;
function adjustPriceScaleForArray(dataArray){
  const arr = dataArray.filter(v => (v !== null && !isNaN(v)));
  if (!arr.length) return;
  const rawMin = Math.min(...arr), rawMax = Math.max(...arr);
  const minRangeAbsolute = Math.max(0.5, Math.abs(rawMax) * 0.00012); // tighter floor
  let range = rawMax - rawMin; if (range < minRangeAbsolute) range = minRangeAbsolute;
  const padPct = 0.015; // 1.5% padding for very tight view
  const pad = Math.max(range * padPct, minRangeAbsolute);
  const targetMin = Math.max(0, rawMin - pad), targetMax = rawMax + pad;
  const emaAlpha = 0.28; // faster but still smooth
  if (emaPriceMin === null || emaPriceMax === null){ emaPriceMin = targetMin; emaPriceMax = targetMax; }
  else { emaPriceMin = emaAlpha * targetMin + (1-emaAlpha) * emaPriceMin; emaPriceMax = emaAlpha * targetMax + (1-emaAlpha) * emaPriceMax; }
  if (emaPriceMax - emaPriceMin < minRangeAbsolute){ const mid = (emaPriceMax + emaPriceMin)/2; emaPriceMin = Math.max(0, mid - minRangeAbsolute/2); emaPriceMax = mid + minRangeAbsolute/2; }
  chart.options.scales.price.min = emaPriceMin; chart.options.scales.price.max = emaPriceMax;
}

// ---------- helpers ----------
function pushTick(symbol, label, price, qty){
  if (symbol === 'BTC'){
    btcLabels.push(label); btcPrices.push(price ?? null); btcVolumes.push(qty ?? 0);
    while (btcLabels.length > MAX_POINTS){ btcLabels.shift(); btcPrices.shift(); btcVolumes.shift(); }
  } else {
    ethLabels.push(label); ethPrices.push(price ?? null); ethVolumes.push(qty ?? 0);
    while (ethLabels.length > MAX_POINTS){ ethLabels.shift(); ethPrices.shift(); ethVolumes.shift(); }
  }
}

function formatChange(current, previous){
  if (current == null || previous == null) return '';
  const diff = current - previous; const pct = (diff / previous) * 100; const sign = diff >= 0 ? '+' : '-';
  return `${sign}${Math.abs(pct).toFixed(2)}%`;
}

function updateRightPanelUI(){
  document.getElementById('btcLive').textContent = lastBTC ? Number(lastBTC).toLocaleString() : '—';
  document.getElementById('ethLive').textContent = lastETH ? Number(lastETH).toLocaleString() : '—';
  document.getElementById('btcChange').textContent = prevBTC ? formatChange(lastBTC, prevBTC) : '';
  document.getElementById('ethChange').textContent = prevETH ? formatChange(lastETH, prevETH) : '';
  document.getElementById('priceStatus').textContent = `BTC USDT: ${lastBTC ? Number(lastBTC).toLocaleString() : '—'}`;
  document.getElementById('last').textContent = `Last update: ${new Date().toLocaleString()}`;
}

// tiny sparklines
const btcSpark = document.getElementById('btcSpark').getContext('2d');
const ethSpark = document.getElementById('ethSpark').getContext('2d');
function drawSpark(ctx2d, arr, color){
  const canvas = ctx2d.canvas; const w = canvas.width = canvas.clientWidth; const h = canvas.height = canvas.clientHeight;
  ctx2d.clearRect(0,0,w,h);
  const vals = arr.slice(-40).filter(v=>v!=null);
  if (!vals.length) return;
  const min = Math.min(...vals), max = Math.max(...vals); const range = Math.max(max-min, 1e-6);
  ctx2d.beginPath(); ctx2d.lineWidth = 2; ctx2d.strokeStyle = color;
  for (let i=0;i<vals.length;i++){ const x = (i/(vals.length-1))*w; const y = h - ((vals[i]-min)/range)*h; if (i===0) ctx2d.moveTo(x,y); else ctx2d.lineTo(x,y); }
  ctx2d.stroke();
}

// ---------- swap chart view ----------
function setActiveSymbol(symbol){
  if (symbol === activeSymbol) return;
  activeSymbol = symbol;
  document.getElementById('btcPanel').classList.toggle('active', activeSymbol === 'BTC');
  document.getElementById('ethPanel').classList.toggle('active', activeSymbol === 'ETH');
  document.getElementById('btcPanel').setAttribute('aria-pressed', activeSymbol === 'BTC');
  document.getElementById('ethPanel').setAttribute('aria-pressed', activeSymbol === 'ETH');

  if (activeSymbol === 'BTC'){
    chart.data.labels = btcLabels;
    chart.data.datasets[0].data = btcPrices;
    chart.data.datasets[1].data = btcVolumes;
    chart.data.datasets[0].borderColor = '#f7931a';
    chart.data.datasets[0].backgroundColor = '#f7931a';
    chart.data.datasets[1].backgroundColor = 'rgba(247,147,26,0.22)';
  } else {
    chart.data.labels = ethLabels;
    chart.data.datasets[0].data = ethPrices;
    chart.data.datasets[1].data = ethVolumes;
    chart.data.datasets[0].borderColor = '#2f7ed8';
    chart.data.datasets[0].backgroundColor = '#2f7ed8';
    chart.data.datasets[1].backgroundColor = 'rgba(47,126,216,0.18)';
  }

  emaPriceMin = null; emaPriceMax = null;
  const dataToUse = (activeSymbol === 'BTC') ? btcPrices : ethPrices;
  adjustPriceScaleForArray(dataToUse);
  chart.update(); // animate to new dataset smoothly
}

// ---------- WebSocket (combined) + REST fallback ----------
let socket = null, restTimer = null;
function startWebSocket(){
  // session start times are symbolStart[*] — defaulted to page load
  const url = 'wss://stream.binance.com/stream?streams=btcusdt@trade/ethusdt@trade';
  try {
    socket = new WebSocket(url);

    socket.onopen = () => {
      console.log('WS open', url);
      document.getElementById('startedAt').textContent = 'Started at: ' + new Date(pageLoadTime).toLocaleTimeString();
      document.getElementById('last').textContent = 'Last update: connected (websocket)';
      stopRestFallback();
    };

    socket.onmessage = (evt) => {
      try {
        const payload = JSON.parse(evt.data);
        const stream = payload.stream;
        const d = payload.data;
        const tradeTs = d.T || Date.now();
        const price = parseFloat(d.p);
        const qty = parseFloat(d.q);
        const label = `+${((tradeTs - pageLoadTime)/1000).toFixed(2)}s`;

        if (stream && stream.startsWith('btcusdt')) {
          prevBTC = lastBTC; lastBTC = price;
          // only collect ticks after symbolStart.BTC
          if (tradeTs >= (symbolStart.BTC || pageLoadTime)){
            pushTick('BTC', label, price, qty);
            drawSpark(btcSpark, btcPrices, '#f7931a');
            if (activeSymbol === 'BTC'){ adjustPriceScaleForArray(btcPrices); chart.update(); }
          } else {
            // still update spark/live numbers even if before start
            drawSpark(btcSpark, btcPrices, '#f7931a');
          }
          document.getElementById('btcLive').textContent = lastBTC ? Number(lastBTC).toLocaleString() : '—';
          document.getElementById('btcChange').textContent = prevBTC ? formatChange(lastBTC, prevBTC) : '';
        } else if (stream && stream.startsWith('ethusdt')) {
          prevETH = lastETH; lastETH = price;
          if (tradeTs >= (symbolStart.ETH || pageLoadTime)){
            pushTick('ETH', label, price, qty);
            drawSpark(ethSpark, ethPrices, '#2f7ed8');
            if (activeSymbol === 'ETH'){ adjustPriceScaleForArray(ethPrices); chart.update(); }
          } else {
            drawSpark(ethSpark, ethPrices, '#2f7ed8');
          }
          document.getElementById('ethLive').textContent = lastETH ? Number(lastETH).toLocaleString() : '—';
          document.getElementById('ethChange').textContent = prevETH ? formatChange(lastETH, prevETH) : '';
        }

        updateRightPanelUI();
      } catch (err){
        console.error('ws parse error', err);
      }
    };

    socket.onerror = (err) => {
      console.error('WS error', err);
      document.getElementById('last').textContent = 'Last update: websocket error — falling back to REST';
      startRestFallback();
    };

    socket.onclose = (ev) => {
      console.warn('WS closed', ev);
      if (!ev.wasClean) startRestFallback();
    };
  } catch (e){
    console.error('WS start failed', e);
    startRestFallback();
  }
}

function startRestFallback(){
  if (restTimer) return;
  REST_INTERVAL_SEC = Math.max(1, Number(document.getElementById('fallbackInterval').value) || 5);
  restTimer = setInterval(async () => {
    try {
      const [btcResp, ethResp] = await Promise.all([
        fetch('https://api.binance.com/api/v3/trades?symbol=BTCUSDT&limit=1'),
        fetch('https://api.binance.com/api/v3/trades?symbol=ETHUSDT&limit=1')
      ]);
      const btcArr = await btcResp.json();
      const ethArr = await ethResp.json();

      if (Array.isArray(btcArr) && btcArr.length){
        const t = btcArr[0].time;
        const p = parseFloat(btcArr[0].price);
        prevBTC = lastBTC; lastBTC = p;
        if (t >= (symbolStart.BTC || pageLoadTime)){
          pushTick('BTC', `+${((t - pageLoadTime)/1000).toFixed(2)}s`, p, parseFloat(btcArr[0].qty));
          drawSpark(btcSpark, btcPrices, '#f7931a');
          if (activeSymbol === 'BTC'){ adjustPriceScaleForArray(btcPrices); chart.update(); }
        } else {
          drawSpark(btcSpark, btcPrices, '#f7931a');
        }
        document.getElementById('btcLive').textContent = lastBTC ? Number(lastBTC).toLocaleString() : '—';
        document.getElementById('btcChange').textContent = prevBTC ? formatChange(lastBTC, prevBTC) : '';
      }

      if (Array.isArray(ethArr) && ethArr.length){
        const t2 = ethArr[0].time;
        const p2 = parseFloat(ethArr[0].price);
        prevETH = lastETH; lastETH = p2;
        if (t2 >= (symbolStart.ETH || pageLoadTime)){
          pushTick('ETH', `+${((t2 - pageLoadTime)/1000).toFixed(2)}s`, p2, parseFloat(ethArr[0].qty));
          drawSpark(ethSpark, ethPrices, '#2f7ed8');
          if (activeSymbol === 'ETH'){ adjustPriceScaleForArray(ethPrices); chart.update(); }
        } else {
          drawSpark(ethSpark, ethPrices, '#2f7ed8');
        }
        document.getElementById('ethLive').textContent = lastETH ? Number(lastETH).toLocaleString() : '—';
        document.getElementById('ethChange').textContent = prevETH ? formatChange(lastETH, prevETH) : '';
      }

      updateRightPanelUI();
    } catch (err) {
      console.error('REST fallback error', err);
    }
  }, REST_INTERVAL_SEC * 1000);

  document.getElementById('last').textContent = 'Last update: using REST fallback';
}

function stopRestFallback(){ if (restTimer){ clearInterval(restTimer); restTimer = null; } }

// ---------- UI behaviors ----------
function handlePanelClick(symbol){
  const startOnClick = document.getElementById('startOnClick').checked;
  if (startOnClick){
    // clear symbol data and set its start to now
    symbolStart[symbol] = Date.now();
    if (symbol === 'BTC'){ btcLabels.length=0; btcPrices.length=0; btcVolumes.length=0; }
    else { ethLabels.length=0; ethPrices.length=0; ethVolumes.length=0; }
  }
  setActiveSymbol(symbol);
}

document.getElementById('btcPanel').addEventListener('click', ()=> handlePanelClick('BTC'));
document.getElementById('ethPanel').addEventListener('click', ()=> handlePanelClick('ETH'));

// clear buttons (stop propagation so it doesn't trigger panel click)
document.getElementById('btcClear').addEventListener('click', (ev) => { ev.stopPropagation(); btcLabels.length=0; btcPrices.length=0; btcVolumes.length=0; emaPriceMin=null; emaPriceMax=null; if (activeSymbol==='BTC') chart.update(); });
document.getElementById('ethClear').addEventListener('click', (ev) => { ev.stopPropagation(); ethLabels.length=0;
