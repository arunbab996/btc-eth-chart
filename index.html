<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BTC Tick Chart — btc.heyabc.xyz</title>

  <!-- Favicon: Bitcoin mark (inline SVG) -->
  <link rel="icon" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='50' fill='%23f7931a'/><text x='50' y='62' font-size='56' text-anchor='middle' fill='white' font-family='Arial, Helvetica, sans-serif'>฿</text></svg>">

  <!-- Chart.js v4 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <style>
    :root{--bg:#f5f7fb;--card:#fff;--muted:#6b7280;--accent:#f7931a}
    html,body{height:100%;margin:0;overflow:hidden}
    body{
      background:var(--bg);
      font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial;
      color:#071122;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:12px;
      box-sizing:border-box;
    }

    /* Outer card centered and fully visible without scrolling */
    .card{
      width:96%;
      max-width:1240px;
      background:var(--card);
      border-radius:12px;
      padding:14px;
      box-shadow:0 10px 30px rgba(12,20,44,0.06);
      box-sizing:border-box;
      /* keep entire card in viewport */
      max-height: calc(100vh - 24px);
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:hidden;
    }

    header{display:flex;align-items:flex-start;justify-content:space-between;gap:12px}
    .left{display:flex;flex-direction:column;gap:6px}
    h1{margin:0;font-size:16px}
    .meta{font-size:13px;color:var(--muted)}
    .controls{display:flex;gap:8px;align-items:center}
    input,button,select{padding:6px 8px;border-radius:8px;border:1px solid #e6e9ef;background:white}
    #chart{width:100%; /* dynamic height below */ display:block}

    /* layout: chart area + right column for live prices */
    .main {
      display:flex;
      gap:12px;
      align-items:stretch;
      flex:1 1 auto; /* allow to grow to fill card */
      min-height:0;   /* necessary to let child overflow hidden behave */
    }

    .chart-wrap {
      flex: 1 1 auto;
      min-height:0; /* important to allow canvas sizing */
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .right {
      width:260px;
      flex:0 0 260px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:flex-start;
      box-sizing:border-box;
    }

    .price-card {
      width:100%;
      background:#fff;
      border-radius:8px;
      padding:10px;
      box-shadow:0 4px 12px rgba(12,20,44,0.04);
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    .price-label { font-size:12px;color:var(--muted) }
    .price-value { font-weight:700;font-size:18px }

    footer{font-size:12px;color:var(--muted);text-align:center}

    /* Ensure canvas fits inside available vertical space */
    /* The  chart-area height = card max-height minus header/controls/footers margins.
       These numbers are conservative so chart will never force page scroll. */
    .chart-canvas {
      flex:1 1 auto;
      min-height:0;
      position:relative;
    }
    canvas { width:100% !important; height:100% !important; display:block; }

    @media (max-width:980px){
      .right { width:180px; flex:0 0 180px }
    }
    @media (max-width:700px){
      .card{padding:12px}
      header{flex-direction:column;align-items:flex-start}
      .main{flex-direction:column}
      .right{width:100%;flex:0 0 auto;order:2}
      .chart-wrap{order:1}
    }
  </style>
</head>
<body data-ref-image="/mnt/data/Screenshot 2025-11-22 at 3.24.00 PM.png">
  <div class="card" role="main">
    <header>
      <div class="left">
        <h1>Live Tick Chart — BTC/USDT</h1>
        <div class="meta">Stream: <code>btcusdt@trade</code> &amp; <code>ethusdt@trade</code> (ETH shown live on the right). Chart builds from the moment you load the page.</div>
      </div>

      <div class="controls" aria-hidden="false">
        <label class="meta">Max ticks</label>
        <input id="maxPoints" type="number" min="50" value="400" style="width:90px" />
        <label class="meta">Fallback</label>
        <select id="fallbackInterval" title="REST fallback interval (seconds)">
          <option value="2">2s</option>
          <option value="5" selected>5s</option>
          <option value="10">10s</option>
        </select>
        <button id="apply">Apply</button>
      </div>
    </header>

    <div class="main">
      <div class="chart-wrap">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
          <div id="priceStatus">BTC USDT: —</div>
          <div id="startedAt" class="meta">Started at: —</div>
        </div>

        <div class="chart-canvas">
          <canvas id="chart" aria-label="Live BTC tick chart"></canvas>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center">
          <div id="last" class="meta">Last update: —</div>
          <div class="meta">Source: Binance WebSocket</div>
        </div>
      </div>

      <div class="right" aria-label="Live prices">
        <!-- ETH + BTC live price panels (separate, on the right side) -->
        <div class="price-card" id="btcPanel" aria-live="polite">
          <div class="price-label">BTC (Live)</div>
          <div class="price-value" id="btcLive">—</div>
          <div class="meta" id="btcChange"> </div>
        </div>

        <div class="price-card" id="ethPanel" aria-live="polite">
          <div class="price-label">ETH (Live)</div>
          <div class="price-value" id="ethLive">—</div>
          <div class="meta" id="ethChange"> </div>
        </div>

        <!-- Hidden reference image (path provided) - tooling can convert this to a URL -->
        <img src="/mnt/data/Screenshot 2025-11-22 at 3.24.00 PM.png" alt="ref" style="display:none" />
      </div>
    </div>

    <footer>Tip: if using Cloudflare, set the DNS record to DNS-only (grey cloud) to allow WebSocket upgrades.</footer>
  </div>

<script>
/*
  Updates made:
  - Tighter Y-axis: lower padding and faster smoothing for visible moves.
  - Chart fits viewport (no vertical scroll).
  - Live BTC and ETH prices on right; only BTC ticks are plotted.
  - Uses combined stream: btcusdt@trade/ethusdt@trade
*/

// ---------- config / globals ----------
let MAX_POINTS = Math.max(50, Number(document.getElementById('maxPoints').value) || 400);
let REST_INTERVAL_SEC = Number(document.getElementById('fallbackInterval').value) || 5;

let startTime = Date.now();
let started = false;

const labels = [];
const btcPrices = [];
const btcVolumes = [];

const ctx = document.getElementById('chart').getContext('2d');

// ---------- Chart.js setup ----------
const chart = new Chart(ctx, {
  data: {
    labels: labels,
    datasets: [
      {
        type: 'line',
        label: 'BTC Price (USDT)',
        data: btcPrices,
        borderColor: '#f7931a',
        backgroundColor: '#f7931a',
        borderWidth: 2,
        pointRadius: 3,
        stepped: true,
        yAxisID: 'price',
        tension: 0.04,
      },
      {
        type: 'bar',
        label: 'BTC Qty',
        data: btcVolumes,
        backgroundColor: 'rgba(247,147,26,0.22)',
        yAxisID: 'volume',
      }
    ]
  },
  options: {
    animation: false,
    maintainAspectRatio: false,
    responsive: true,
    interaction: { mode: 'index', intersect: false },
    plugins: { legend: { position: 'top' } },
    scales: {
      x: { ticks: { maxRotation: 45, autoSkip: true, maxTicksLimit: 30 } },
      price: {
        type: 'linear',
        position: 'left',
        title: { display: true, text: 'Price (USDT)' },
        grid: { drawOnChartArea: true }
      },
      volume: {
        type: 'linear',
        position: 'right',
        title: { display: true, text: 'Quantity' },
        grid: { drawOnChartArea: false }
      }
    }
  }
});

// ---------- improved dynamic axis with tighter padding & faster smoothing ----------
let emaPriceMin = null;
let emaPriceMax = null;

function adjustPriceScale(){
  const arr = btcPrices.filter(v => (v !== null && !isNaN(v)));
  if (!arr.length) return;

  const rawMin = Math.min(...arr);
  const rawMax = Math.max(...arr);

  // Tighter floor: smaller absolute floor (0.02% of price, but at least 0.5 USD)
  const minRangeAbsolute = Math.max(0.5, Math.abs(rawMax) * 0.0002); // 0.02% floor

  let range = rawMax - rawMin;
  if (range < minRangeAbsolute) range = minRangeAbsolute;

  // MUCH smaller padding than before for tighter view
  const padPct = 0.03; // 3% padding
  const pad = Math.max(range * padPct, minRangeAbsolute);

  const targetMin = Math.max(0, rawMin - pad);
  const targetMax = rawMax + pad;

  // EMA smoothing (more responsive)
  const emaAlpha = 0.18; // higher alpha => faster follow
  if (emaPriceMin === null || emaPriceMax === null){
    emaPriceMin = targetMin;
    emaPriceMax = targetMax;
  } else {
    emaPriceMin = emaAlpha * targetMin + (1 - emaAlpha) * emaPriceMin;
    emaPriceMax = emaAlpha * targetMax + (1 - emaAlpha) * emaPriceMax;
  }

  if (emaPriceMax - emaPriceMin < minRangeAbsolute){
    const mid = (emaPriceMax + emaPriceMin) / 2;
    emaPriceMin = Math.max(0, mid - minRangeAbsolute/2);
    emaPriceMax = mid + minRangeAbsolute/2;
  }

  chart.options.scales.price.min = emaPriceMin;
  chart.options.scales.price.max = emaPriceMax;
}

// ---------- helpers ----------
function pushPoint(label, price, qty){
  labels.push(label);
  btcPrices.push(price ?? null);
  btcVolumes.push(qty ?? 0);

  while(labels.length > MAX_POINTS){
    labels.shift(); btcPrices.shift(); btcVolumes.shift();
  }
}

function updateUI(lastPrice){
  document.getElementById('priceStatus').textContent = `BTC USDT: ${lastPrice ? Number(lastPrice).toLocaleString() : '—'}`;
  document.getElementById('last').textContent = `Last update: ${new Date().toLocaleString()}`;
}

// ---------- WebSocket (combined stream: BTC + ETH) + REST fallback ----------
let socket = null;
let restTimer = null;
let lastBTC = null;
let lastETH = null;
let prevBTC = null;
let prevETH = null;

function formatChange(current, previous){
  if (current == null || previous == null) return '';
  const diff = current - previous;
  const pct = (diff / previous) * 100;
  const sign = diff >= 0 ? '+' : '-';
  return `${sign}${Math.abs(pct).toFixed(2)}%`;
}

function startWebSocket(){
  // reset session
  startTime = Date.now();
  started = false;
  labels.length = 0; btcPrices.length = 0; btcVolumes.length = 0;
  chart.update();

  const url = 'wss://stream.binance.com/stream?streams=btcusdt@trade/ethusdt@trade';
  try{
    socket = new WebSocket(url);

    socket.onopen = () => {
      console.log('WS open:', url);
      started = true;
      document.getElementById('startedAt').textContent = 'Started at: ' + new Date(startTime).toLocaleTimeString();
      document.getElementById('last').textContent = 'Last update: connected (websocket)';
      stopRestFallback();
    };

    socket.onmessage = (evt) => {
      try{
        const payload = JSON.parse(evt.data);
        const stream = payload.stream;
        const d = payload.data;
        const tradeTs = d.T || d.tradeTime || Date.now();

        // ETH and BTC prices shown live on right; only plot BTC trades (after startTime)
        if (stream && stream.startsWith('btcusdt')) {
          const price = parseFloat(d.p);
          const qty = parseFloat(d.q);
          if (tradeTs >= startTime) {
            const label = `+${((tradeTs - startTime)/1000).toFixed(2)}s`;
            pushPoint(label, price, qty);
            lastBTC = price;
            adjustPriceScale();
            chart.update('none');
            updateUI(lastBTC);
          } else {
            // update lastBTC even if before startTime so right-side shows live latest
            lastBTC = price;
            updateUI(lastBTC);
          }
          // update right panel values & pct chg
          const prev = prevBTC; prevBTC = lastBTC;
          document.getElementById('btcLive').textContent = lastBTC ? Number(lastBTC).toLocaleString() : '—';
          document.getElementById('btcChange').textContent = prev ? formatChange(lastBTC, prev) : '';
        } else if (stream && stream.startsWith('ethusdt')) {
          const price = parseFloat(d.p);
          lastETH = price;
          const prev = prevETH; prevETH = lastETH;
          document.getElementById('ethLive').textContent = lastETH ? Number(lastETH).toLocaleString() : '—';
          document.getElementById('ethChange').textContent = prev ? formatChange(lastETH, prev) : '';
        }
      } catch(e) { console.error('ws onmessage parse', e); }
    };

    socket.onerror = (err) => {
      console.error('WS error', err);
      document.getElementById('last').textContent = 'Last update: websocket error — falling back to REST';
      startRestFallback();
    };

    socket.onclose = (ev) => {
      console.warn('WS closed', ev);
      if (!ev.wasClean) startRestFallback();
    };
  } catch(e){
    console.error('WS start failed', e);
    startRestFallback();
  }
}

function startRestFallback(){
  if (restTimer) return;
  REST_INTERVAL_SEC = Math.max(1, Number(document.getElementById('fallbackInterval').value) || 5);
  restTimer = setInterval(async () => {
    try{
      // latest trade for BTC and ETH
      const [btcResp, ethResp] = await Promise.all([
        fetch('https://api.binance.com/api/v3/trades?symbol=BTCUSDT&limit=1'),
        fetch('https://api.binance.com/api/v3/trades?symbol=ETHUSDT&limit=1')
      ]);
      const btcArr = await btcResp.json();
      const ethArr = await ethResp.json();

      if (Array.isArray(btcArr) && btcArr.length){
        const t = btcArr[0].time;
        lastBTC = parseFloat(btcArr[0].price);
        const prev = prevBTC; prevBTC = lastBTC;
        document.getElementById('btcLive').textContent = lastBTC ? Number(lastBTC).toLocaleString() : '—';
        document.getElementById('btcChange').textContent = prev ? formatChange(lastBTC, prev) : '';

        if (t >= startTime){
          const label = `+${((t - startTime)/1000).toFixed(2)}s`;
          pushPoint(label, lastBTC, parseFloat(btcArr[0].qty));
          adjustPriceScale(); chart.update('none'); updateUI(lastBTC);
        }
      }
      if (Array.isArray(ethArr) && ethArr.length){
        lastETH = parseFloat(ethArr[0].price);
        const prev = prevETH; prevETH = lastETH;
        document.getElementById('ethLive').textContent = lastETH ? Number(lastETH).toLocaleString() : '—';
        document.getElementById('ethChange').textContent = prev ? formatChange(lastETH, prev) : '';
      }
    } catch(err){ console.error('REST fallback error', err); }
  }, REST_INTERVAL_SEC * 1000);

  document.getElementById('last').textContent = 'Last update: using REST fallback';
}

function stopRestFallback(){ if (restTimer){ clearInterval(restTimer); restTimer = null; } }

// controls
document.getElementById('apply').addEventListener('click', () => {
  MAX_POINTS = Math.max(50, Number(document.getElementById('maxPoints').value) || 400);
  REST_INTERVAL_SEC = Math.max(1, Number(document.getElementById('fallbackInterval').value) || 5);
  labels.length = 0; btcPrices.length = 0; btcVolumes.length = 0; chart.update();
  try{ if (socket) socket.close(); } catch(e){}
  startWebSocket();
});

// start on load
startWebSocket();

// cleanup
window.addEventListener('beforeunload', ()=>{ try{ if (socket) socket.close(); }catch(e){} stopRestFallback(); });
</script>
</body>
</html>
